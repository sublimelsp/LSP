[
    {
        "documentation": "",
        "label": "abc",
        "insertText": "abc",
        "detail": "os",
        "sortText": "aabc",
        "kind": 9
    },
    {
        "documentation": "Abort the interpreter immediately. This function 'dumps core' or otherwise fails in the hardest way possible on the hosting operating system.  This function never returns.",
        "label": "abort()",
        "insertText": "abort",
        "detail": "os",
        "sortText": "aabort",
        "kind": 3
    },
    {
        "documentation": "Use the real uid/gid to test for access to a path.   path     Path to be tested; can be string or bytes   mode     Operating-system mode bitfield.  Can be F_OK to test existence,     or the inclusive-OR of R_OK, W_OK, and X_OK.   dir_fd     If not None, it should be a file descriptor open to a directory,     and path should be relative; path will then be relative to that     directory.   effective_ids     If True, access will use the effective uid/gid instead of     the real uid/gid.   follow_symlinks     If False, and the last element of the path is a symbolic link,     access will examine the symbolic link itself instead of the file     the link points to. dir_fd, effective_ids, and follow_symlinks may not be implemented   on your platform.  If they are unavailable, using them will raise a   NotImplementedError. Note that most operations will use the effective uid/gid, therefore this   routine can be used in a suid/sgid environment to test if the invoking user   has the specified access to the path.",
        "label": "access(path, mode, dir_fd, effective_ids, follow_symlinks)",
        "insertText": "access(${1:path}, ${2:mode}, ${3:dir_fd}, ${4:effective_ids}, ${5:follow_symlinks})$0",
        "detail": "os",
        "sortText": "aaccess",
        "insertTextFormat": 2,
        "kind": 3
    },
    {
        "documentation": "",
        "label": "altsep",
        "insertText": "altsep",
        "detail": "os",
        "sortText": "aaltsep",
        "kind": 9
    },
    {
        "documentation": "Change the current working directory to the specified path. path may always be specified as a string. On some platforms, path may also be specified as an open file descriptor.   If this functionality is unavailable, using it raises an exception.",
        "label": "chdir(path)",
        "insertText": "chdir(${1:path})$0",
        "detail": "os",
        "sortText": "achdir",
        "insertTextFormat": 2,
        "kind": 3
    },
    {
        "documentation": "Change the access permissions of a file.   path     Path to be modified.  May always be specified as a str or bytes.     On some platforms, path may also be specified as an open file descriptor.     If this functionality is unavailable, using it raises an exception.   mode     Operating-system mode bitfield.   dir_fd     If not None, it should be a file descriptor open to a directory,     and path should be relative; path will then be relative to that     directory.   follow_symlinks     If False, and the last element of the path is a symbolic link,     chmod will modify the symbolic link itself instead of the file     the link points to. It is an error to use dir_fd or follow_symlinks when specifying path as   an open file descriptor. dir_fd and follow_symlinks may not be implemented on your platform.   If they are unavailable, using them will raise a NotImplementedError.",
        "label": "chmod(path, mode, dir_fd, follow_symlinks)",
        "insertText": "chmod(${1:path}, ${2:mode}, ${3:dir_fd}, ${4:follow_symlinks})$0",
        "detail": "os",
        "sortText": "achmod",
        "insertTextFormat": 2,
        "kind": 3
    },
    {
        "documentation": "Change the owner and group id of path to the numeric uid and gid.   path     Path to be examined; can be string, bytes, or open-file-descriptor int.   dir_fd     If not None, it should be a file descriptor open to a directory,     and path should be relative; path will then be relative to that     directory.   follow_symlinks     If False, and the last element of the path is a symbolic link,     stat will examine the symbolic link itself instead of the file     the link points to. path may always be specified as a string. On some platforms, path may also be specified as an open file descriptor.   If this functionality is unavailable, using it raises an exception. If dir_fd is not None, it should be a file descriptor open to a directory,   and path should be relative; path will then be relative to that directory. If follow_symlinks is False, and the last element of the path is a symbolic   link, chown will modify the symbolic link itself instead of the file the   link points to. It is an error to use dir_fd or follow_symlinks when specifying path as   an open file descriptor. dir_fd and follow_symlinks may not be implemented on your platform.   If they are unavailable, using them will raise a NotImplementedError.",
        "label": "chown(path, uid, gid, dir_fd, follow_symlinks)",
        "insertText": "chown(${1:path}, ${2:uid}, ${3:gid}, ${4:dir_fd}, ${5:follow_symlinks})$0",
        "detail": "os",
        "sortText": "achown",
        "insertTextFormat": 2,
        "kind": 3
    },
    {
        "documentation": "Change root directory to path.",
        "label": "chroot(path)",
        "insertText": "chroot(${1:path})$0",
        "detail": "os",
        "sortText": "achroot",
        "insertTextFormat": 2,
        "kind": 3
    },
    {
        "documentation": "int(x=0) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.__int__().  For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4",
        "label": "CLD_CONTINUED",
        "insertText": "CLD_CONTINUED",
        "detail": "os",
        "sortText": "aCLD_CONTINUED",
        "kind": 18
    },
    {
        "documentation": "int(x=0) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.__int__().  For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4",
        "label": "CLD_DUMPED",
        "insertText": "CLD_DUMPED",
        "detail": "os",
        "sortText": "aCLD_DUMPED",
        "kind": 18
    },
    {
        "documentation": "int(x=0) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.__int__().  For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4",
        "label": "CLD_EXITED",
        "insertText": "CLD_EXITED",
        "detail": "os",
        "sortText": "aCLD_EXITED",
        "kind": 18
    },
    {
        "documentation": "int(x=0) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given.  If x is a number, return x.__int__().  For floating point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base.  The literal can be preceded by '+' or '-' and be surrounded by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. >>> int('0b100', base=0) 4",
        "label": "CLD_TRAPPED",
        "insertText": "CLD_TRAPPED",
        "detail": "os",
        "sortText": "aCLD_TRAPPED",
        "kind": 18
    },
    {
        "documentation": "Close a file descriptor.",
        "label": "close(fd)",
        "insertText": "close(${1:fd})$0",
        "detail": "os",
        "sortText": "aclose",
        "insertTextFormat": 2,
        "kind": 3
    },
    {
        "documentation": "Closes all file descriptors in [fd_low, fd_high), ignoring errors.",
        "label": "closerange(fd_low, fd_high)",
        "insertText": "closerange(${1:fd_low}, ${2:fd_high})$0",
        "detail": "os",
        "sortText": "acloserange",
        "insertTextFormat": 2,
        "kind": 3
    },
    {
        "documentation": "Return a string-valued system configuration variable.",
        "label": "confstr(name)",
        "insertText": "confstr(${1:name})$0",
        "detail": "os",
        "sortText": "aconfstr",
        "insertTextFormat": 2,
        "kind": 3
    },
    {
        "documentation": "dict() -> new empty dictionary dict(mapping) -> new dictionary initialized from a mapping object's     (key, value) pairs dict(iterable) -> new dictionary initialized as if via:     d = {}     for k, v in iterable:         d[k] = v dict(**kwargs) -> new dictionary initialized with the name=value pairs     in the keyword argument list.  For example:  dict(one=1, two=2)",
        "label": "confstr_names",
        "insertText": "confstr_names",
        "detail": "os",
        "sortText": "aconfstr_names",
        "kind": 18
    },
    {
        "documentation": "Return the number of CPUs in the system; return None if indeterminable. This number is not equivalent to the number of CPUs the current process can use.  The number of usable CPUs can be obtained with ``len(os.sched_getaffinity(0))``",
        "label": "cpu_count()",
        "insertText": "cpu_count",
        "detail": "os",
        "sortText": "acpu_count",
        "kind": 3
    },
    {
        "documentation": "Return the name of the controlling terminal for this process.",
        "label": "ctermid()",
        "insertText": "ctermid",
        "detail": "os",
        "sortText": "actermid",
        "kind": 3
    },
    {
        "documentation": "",
        "label": "curdir",
        "insertText": "curdir",
        "detail": "os",
        "sortText": "acurdir",
        "kind": 9
    },
    {
        "documentation": "",
        "label": "defpath",
        "insertText": "defpath",
        "detail": "os",
        "sortText": "adefpath",
        "kind": 9
    },
    {
        "documentation": "Return a string describing the encoding of a terminal's file descriptor. The file descriptor must be attached to a terminal. If the device is not a terminal, return None.",
        "label": "device_encoding(fd)",
        "insertText": "device_encoding(${1:fd})$0",
        "detail": "os",
        "sortText": "adevice_encoding",
        "insertTextFormat": 2,
        "kind": 3
    }
]
